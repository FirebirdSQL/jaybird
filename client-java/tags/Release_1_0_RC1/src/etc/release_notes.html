<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=windows-1252">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 641  (Win32)">
	<META NAME="CREATED" CONTENT="20020909;21125147">
	<META NAME="CHANGED" CONTENT="16010101;0">
</HEAD>
<BODY LANG="en-US">
<P ALIGN=CENTER><FONT SIZE=6>JCA/JDBC Firebird ("JayBird") Driver Release Notes</FONT></P>
<P ALIGN=CENTER>- Last Updated 09/09/02 -</P>
<P ALIGN=CENTER><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5 STYLE="font-size: 20pt">CONTENTS</FONT></P>
<P><BR><BR>
</P>
<P STYLE="margin-left: 8cm">1. Introduction</P>
<P STYLE="margin-left: 8cm">2. What Is and Is NOT Supported</P>
<P STYLE="margin-left: 8cm">3. Where to get the driver</P>
<P STYLE="margin-left: 8cm">4. Installing the driver</P>
<P STYLE="margin-left: 8cm">5. Connection Pooling</P>
<P STYLE="margin-left: 8cm">6. Using the Driver in Java Code</P>
<P STYLE="margin-left: 8cm">7. Using the Driver with JBoss</P>
<P STYLE="margin-left: 8cm">8. Using the Driver with Tomcat</P>
<P STYLE="margin-left: 8cm">9. Using the Driver With JBuilder</P>
<P STYLE="margin-left: 8cm">10. Using Blobs</P>
<P STYLE="margin-left: 8cm">11. Using Multi-Byte Character sets</P>
<P STYLE="margin-left: 8cm">12. Reporting Bugs</P>
<P STYLE="margin-left: 8cm">13. Obtaining Sources from SourceForge
using CVS</P>
<P STYLE="margin-left: 8cm">14. Participating in the Development
Project</P>
<P STYLE="margin-left: 8cm">15. Where to get help</P>
<P STYLE="margin-left: 8cm">16. Joining the Mailing List</P>
<P STYLE="margin-left: 8cm">17. Known Bugs</P>
<P STYLE="margin-left: 8cm">18. Additional JAR libraries needed to
use the driver</P>
<P STYLE="margin-left: 8cm">19. Code Examples</P>
<P STYLE="margin-left: 8cm">20. Common Errors</P>
<P STYLE="margin-left: 8cm">21. Compliance and Performance
Information</P>
<P STYLE="margin-left: 8cm">22. History</P>
<P STYLE="margin-left: 8cm">23. Frequently Asked Questions</P>
<P STYLE="margin-left: 8cm">24. To Do</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=4 STYLE="font-size: 16pt">1- <FONT SIZE=5>Introduction</FONT></FONT></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P>The firebird team has implemented a pure java driver for
firebirdsql. This driver allows a Java program to connect to, send
queries to, and get results from a Firebird SQL Database. It is an
alternative to the Interclient JDBC Driver. The open source version
of Interclient is not actively supported at this time. This makes the
JCA-JDBC Driver the best option for Java development with an open
source driver.</P>
<P>This driver is based on both the new JCA standard for application
server connections to enterprise information systems and the well
known jdbc standard. The JCA standard specifies an architecture in
which an application server can cooperate with a driver so that the
application server manages transactions, security, and resource
pooling, and the driver supplies only the connection functionality.
While similar to the JDBC 2 XADataSource idea, the JCA specification
is considerably clearer on the division of responsibility between the
application server and driver.</P>
<P>The JCA-JDBC driver has several major advantages over Interclient.
Because it Implements the JCA specification, it can be used
seamlessly with J2EE containers that support JCA functionality.</P>
<P>It also has a built-in connection pooling capability for use with
stand-alone programs or J2EE containers that don't support connection
pooling internally. Java programs run much faster with connection
pooling because the overhead of connection setup and teardown is
greatly reduced.</P>
<P>Perhaps the biggest advantage is that Interserver is not needed
with this driver. Interserver had to be installed on the
Firebird/Interbase server machine for the Interclient JDBC driver to
work. The elimination of Interserver simplifies the installation of
the Firebird database, and reduces the load on and maintenance of the
database server system.</P>
<P>The driver implements much of the JDBC 2
Specification. More information on the JDBC 2
Specification can be found on the net at http://java.sun.com.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=4 STYLE="font-size: 16pt">2- What Is and
Is NOT <FONT SIZE=5>Supported</FONT></FONT></P>
<P><BR><BR>
</P>
<P>The driver complies with the JDBC 2.0 core with some features and
methods not implemented. Some of the unimplemented items are required
by the specification and some are optional.</P>
<P><FONT SIZE=4>Implemented features:</FONT></P>
<P>Most useful jdbc functionality (&quot;useful&quot; in the opinion
of the developers).</P>
<P>Complete jca spi support: may be used directly in jca-supporting
application servers such as JBoss. NOTE: in this release it is required that jndi bindings be Referenceable/ObjectFactory based rather than serialization based.  This currently prevents use with WebLogic.</P>
<P>XA transactions with true two phase commit when used as a jca
resource adapter in a managed environment (with a TransactionManager
and jca deployment support).</P>
<P>Includes optional internal connection pooling for standalone use
and use in non-jca environments such as Tomcat 4.</P>
<P>ObjectFactory implementation for use in environments with JNDI but
no TransactionManager such as Tomcat 4.</P>
<P>DataSource implementations with or without pooling.</P>
<P>Driver implementation for use in legacy applications.</P>
<P>Complete access to all Firebird database parameter block and
transaction parameter block settings.</P>
<P>Optional integrated logging through log4j.</P>
<P>JMX mbean for database management (so far just database create and
drop).</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4>The following optional features are NOT supported:</FONT></P>
<UL>
	<LI><P>Batch Updates. 
	</P>
	<LI><P>Scrollable cursors. 
	</P>
	<LI><P>Updatable cursors. 
	</P>
	<LI><P>Cursors/Positioned update/delete 
	</P>
	<LI><P>Ref, Clob and Array types 
	</P>
	<LI><P>User Defined Types/Type Maps.</P>
</UL>
<P>The methods that support those features return SQLExceptions when
used.</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4>In addition to the non supported features above, the
following methods are not implemented:</FONT></P>
<UL>
	<LI><P><FONT FACE="Courier, monospace">java.sql.ResultSetMetaData </FONT>
	</P>
</UL>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">isReadOnly(i)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">isWritable(i)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">isDefinitivelyWritable(i)
</FONT>
</P>
<UL>
	<LI><P><FONT FACE="Courier, monospace">java.sql.Statement </FONT>
	</P>
</UL>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setEscapeProcessing(boolean)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">cancel() </FONT>
</P>
<UL>
	<LI><P><FONT FACE="Courier, monospace">java.sql.PreparedStatement </FONT>
	</P>
</UL>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setObject(index,object,type,scale)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setCharacterStream(i)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setDate(i,date,calendar)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setTime(i,time,calendar)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">setTimestamp(i,timestamp,calendar)
</FONT>
</P>
<UL>
	<LI><P><FONT FACE="Courier, monospace">java.sql.ResultSet </FONT>
	</P>
</UL>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">getDate(i,calendar)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">getTime(i,calendar)
</FONT>
</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">getTimestamp(i,calendar)</FONT></P>
<P STYLE="margin-left: 2cm"><BR><BR>
</P>
<P>The following methods are implemented but do not work as expected</P>
<P><BR><BR>
</P>
<UL>
	<LI><P>java.sql.ResultSet 
	</P>
</UL>
<P STYLE="margin-left: 2cm">get/setFetchSize does nothing 
</P>
<UL>
	<LI><P>java.sql.Statement 
	</P>
</UL>
<P STYLE="margin-left: 2cm">get/setFetchSize does nothing 
</P>
<P STYLE="margin-left: 2cm">get/setMaxFieldSize does nothing 
</P>
<P STYLE="margin-left: 2cm">get/setQueryTimeout does nothing 
</P>
<UL>
	<LI><P>java.sql.PreparedStatement 
	</P>
</UL>
<P STYLE="margin-left: 2cm">setObject(index,object,type) This method
is supported but behaves as setObject(index,object)</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=4 STYLE="font-size: 16pt">3- Where to Get
the <FONT SIZE=5>Driver</FONT></FONT></P>
<P><BR><BR>
</P>
<P>In your browser go to:</P>
<P>http://sourceforge.net/projects/firebird/</P>
<P>scroll down the page and find the row containing:</P>
<P>firebird-jca-jdbc-driver</P>
<P>Click the link &quot;Download&quot; in the rightmost column of the
table in that row. This links you to another page with the zip files
of the various versions of the driver available to be downloaded. The
driver will have the heading &quot;firebird-jca-jdbc-driver&quot;.
Click on the version you wish to download. It looks something like:
FirebirdSQL-1.x.zip.</P>
<P>This will download the driver files to your system. Unzip the file
and copy the contents to the appropriate directories on your system
as described in #4 &quot;Installing the Driver&quot; below.</P>
<P>More recent bugfix versions of the driver can be obtained by
downloading the daily snapshot of the project through CVS and
building the project. See #13 below for details.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=4 STYLE="font-size: 16pt">4- Installing
the <FONT SIZE=5>Driver</FONT></FONT></P>
<P><BR><BR>
</P>
<P>The classes from firebirdsql.jar must be in the classpath of the
Java application being compiled, or otherwise made available to your
application. The classes from the following packages must also be
available:</P>
<UL>
	<LI><P>mini-concurrent.jar</P>
	<LI><P>jaas.jar (included in jdk 1.4)</P>
	<LI><P>mini-j2ee.jar (now including jdbc classes)</P>
	<LI><P>log4j-core.jar (if you want logging available)</P>
</UL>
<P><BR><BR>
</P>
<P>These archives are included in the binary package.</P>
<P><BR><BR>
</P>
<P>You can use the jmx management mbean either in a jmx agent
(MBeanServer) or as a standalone class. So far it has been tested in
jbossmx and the jmxri, although since it is extremely simple it
should have no problems in any jmx implementation. Use of jbossmx is
highly recommended due to its smaller bug count and because it is in
active development.</P>
<P>For use in a managed environment as a jca resource adapter, deploy
firebirdsql.rar according to the environment's deployment mechanism.</P>
<P>For installation in Tomcat, JBoss, JBuilder, and for use with
stand alone Java programs see the corresponding sections below.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>5- Connection Pooling</FONT></P>
<P><BR><BR>
</P>
<P>The JCA-JDBC Driver features built-in connection pooling. This is
very useful because it eliminates the need for external connection
pooling routines like Poolman or DBCP.</P>
<P>Setting up and shutting down JDBC connections to databases tend to
be very time and CPU intensive operations. Connection pooling allows
connections to be stored and re-used by applications, or even by
different applications without going through the time consuming task
of setting up the connection again.</P>
<P>Using a connection pool effectively while preventing data
corruption and unauthorized access requires a slightly different
mindset.</P>
<P>The Firebird database uses the concept of user logins. To access
the database a user must log in and provide a password that the
database recognizes. This is set up by the database administrator.</P>
<P>This can lead to problems with a connection pool. Suppose &quot;joe&quot;
logs in using his password and works with the database. If he logs
out and his connection is kept alive and given to the next user,
&quot;bob&quot;, without re-authorizing, &quot;bob&quot; may be able
to see confidential data that he is not intended to see. Worse he can
change or delete data he should not have access to.</P>
<P>If we only allow users to use connections previously opened with
their username, we drastically reduce the effectiveness of the pool.</P>
<P>To make the pool most effective we have to login with the same
username every time. This requires us to manage the user access to
the database in our code rather that allowing Firebird to do it for
us. This is usually accomplished by creating a table of usernames,
passwords, and roles separate from those maintained by the database.</P>
<P>When a user logs in, all database access is done under a single
username and password known to Firebird, for example username
&quot;calendar&quot;, password &quot;calpass&quot;. The program then
opens a user table created for the application and retrieves the
username, password, and role of the user, which might be &quot;joe&quot;,
&quot;joespassword&quot;, and &quot;manager&quot;. The retrieved
username and password is compared by your program to those provided
by the user. If they match, your program allows the user to perform
actions on the database allowed for users with their role, all under
the Firebird username of &quot;calendar&quot;.</P>
<P>When the next user, &quot;bob&quot;, logs in, transactions are
still done with your program using the connection opened with the
&quot;calendar&quot; Firebird username with the database, but the
program checks the &quot;bob&quot; password and role in the
application user table before allowing transactions.</P>
<P>This results in maximum efficiency of connection pools. It is also
compatibe with the way that web application servers handle container
managed security. So even if your program starts out as a standalone
Java program, you can &quot;webify&quot; the database access part of
it very easily.</P>
<P>It is possible to obtain connections with different 
usernames/passwords with pooling enabled, and the connections 
will be kept separate, but this is apt to result in inefficient 
connection usage.</P>
<P>Be aware that the JCA-JDBC Driver provides no encryption. If you
use the driver in a standalone Java program, anyone who can listen to
your network connection can see your usernames, passwords, and data
as it crosses the net. You must take steps to secure your data. You
can do this by all the standard methods: Secure networks, VPN, etc.</P>
<P>A popular way to provide wide acess to your database while still
providing security is to write your application as a web application
that is viewed in a browser, rather than as a stand-alone
application. Then you can restrict your web app to running under
secure HTTP.</P>
<P>If you are using the driver in stand-alone Java applications there
is little need to use anything other than the built-in pooling.</P>
<P>However, in some cases, you may not want to use the built-in
connection pooling. If you are using the driver with a J2EE server
that manages connection pooling, like JBoss, you should deploy the 
driver as a jca resource adapter.</P>
<P>In such cases the container (J2EE Server) needs the driver to be deployed as a jca resource adapter so that it can manage connection usage and pooling, hook the connections up to the transaction manager, and manage the security and supply connections logged as appropriate for the current application user.</P>
<P>If you are using a limited J2EE server you may need to use the
built-in pooling. Versions of Tomcat before 4.1 are an example. From
version 4.1, Tomcat has provided connection pooling via DBCP. Tomcat
is a Servlet and Java Server Pages (JSP) server, but does not provide
full J2EE web application server suport.</P>
<P>Since a large number of installations use only servlets and JSP's,
application servers like Tomcat, JRun, Cold Fusion, Servlet Exec, and
Resin have become very popular. These have varying support for
connection pooling. You will have to check the features of the
particular version of your app server to see if pooling is offered or
if you will need to use the built-in pool from the Driver.</P>
<P>See the sections below on JBoss, Tomcat, and Using the Driver in
Java code for specific information on those environments.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>6- Using the Driver in Java Code</FONT></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P>Two forms of the driver can be used. FBDriver is used much like
the old Interclient driver. FBWrappingDataSource has internal
connection pooling capability. Example of both are included here.</P>
<P>The driver supports two URL syntax formats:</P>
<P STYLE="margin-left: 2cm">Standard format=
jdbc:firebirdsql:[//host[:port]/]&lt;database&gt; 
</P>
<P STYLE="margin-left: 2cm">FB old format=
jdbc:firebirdsql:[host[/port]:]&lt;database&gt;</P>
<P><BR><BR>
</P>
<P>For all environments that do not support jca deployment, make the
classes in firebirdsql.jar available to your application. You will
probably have to use some of the jars mentioned above as necessary.</P>
<P>For use in a somewhat managed environment with JNDI but no jca
support or transaction manager, use the FBDataSourceObjectFactory to
bind a reference to a DataSource into jndi. Tomcat 4 is an example of
this scenario. The JNDI implementation must support use of
References/Referenceable. This will not work if the JNDI
implementation only supports binding serialized objects.</P>
<P>For use in a standalone application that only needs one
connection, use either FBWrappingDataSource or FBDriver.</P>
<P>A typical use of the FBDriver class would use code something like
this:</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">Class.forName(&quot;org.firebirdsql.jdbc.FBDriver&quot;);</FONT></P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">Connection
conn =
DriverManager.getConnection(&quot;jdbc:firebirdsql:localhost/3050:/firebird/test.gdb&quot;,
&quot;sysdba&quot;, &quot;masterkey&quot;);</FONT></P>
<P STYLE="margin-left: 2cm"><BR><BR>
</P>
<P>Or in windows:</P>
<P STYLE="margin-left: 2cm"><FONT FACE="Courier, monospace">DriverManager.getConnection(&quot;jdbc:firebirdsql:localhost/3050:E:\\database\\carwash.gdb&quot;,
&quot;sysdba&quot;, &quot;masterkey&quot;);</FONT></P>
<P><BR><BR>
</P>
<P>For use in a standalone application with multiple connections that
would benefit from connection pooling, use an instance of
FBWrappingDataSource configured for pooling.</P>
<P>A simple example is listed below:</P>
<P><FONT FACE="Courier, monospace">boolean FBDriverLoaded=false; </FONT>
</P>
<P><FONT FACE="Courier, monospace">if (!FBDriverLoaded)</FONT></P>
<P><FONT FACE="Courier, monospace">{ // don't load the driver more
than once.</FONT></P>
<P><FONT FACE="Courier, monospace">try</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">org.firebirdsql.jdbc.FBWrappingDataSource
fbwds = new org.firebirdsql.jdbc.FBWrappingDataSource();</FONT></P>
<P><FONT FACE="Courier, monospace">interclientLoaded = true;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (ResourceException e)</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println(&quot;Could Not
create org.firebirdsql.jdbc.FBWrappingDataSource, error:&quot;+e+&quot;\n&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setDatabaseName(&quot;//localhost:3050/dir1/subdir/myDatabase.gdb&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">// an old format version of the
same url</FONT></P>
<P><FONT FACE="Courier, monospace">//
fbwds.setDatabaseName(&quot;localhost/3050:/dir1/subdir/myDatabase.gdb&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setUser(&quot;sysdba&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setPassword(&quot;masterkey&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setIdleTimeoutMinutes(30);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">fbwds.setPooling(true); // this
turns on pooling for this data source. Max and min must be set.</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">fbwds.setMinSize(5); // this sets
the minimum number of connections to keep in the pool</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setMaxSize(30); // this sets
the maximum number of connections that can be open at one time.</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">try</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">fbwds.setLoginTimeout(10);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (SQLException e)</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println(&quot;Could not
set Login Timout in SQLDriver\n&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">else</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">//System.out.println(&quot;Firebird
Driver already exists, not reloaded.\n&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">Connection c;</FONT></P>
<P><FONT FACE="Courier, monospace">try</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">c = fbwds.getConnection();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (SQLException e)</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">system.out.println(&quot;getting
new fbwds connection failed! Error: &quot;+e+&quot;\n&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">handleError(e);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">// Use the connection &quot;c&quot;
like any other connection then close it.</FONT></P>
<P><FONT FACE="Courier, monospace">c.close();</FONT></P>
<P><FONT FACE="Courier, monospace">// closing c returns it to the
pool.</FONT></P>
<P>Be aware that no security or encryption is built into the driver.
If you use stand-alone Java programs you must provide secure access
to your database to protect your passwords and data.</P>
<P>More Java code for a driver example and a DataSource example are
included in the #19 Code Examples section below.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>7- Using the Driver with JBoss</FONT></P>
<P><BR><BR>
</P>
<P>Deployment in JBoss 3.0.0 and later:</P>
<P><BR>
</P>
<P>The additional jars/classes mentioned above are already available
in JBoss. Put firebirdsql.rar in the deploy directory. Get
firebird-service.xml from your binary jboss distribution or jboss cvs  at
connector[jbosscx]/src/etc/example-config/firebird-service.xml and
modify the URL to point to the desired database location. If you get a configuration from cvs, please be very sure and check twice that you have the correct version for your JBoss version.  There are hard-to-spot incompatibilities between every minor release.</P>
<P>For simplicity, start by setting the UserName and Password in the firebird-service.xml configuration file.  If you need more advanced JAAS based login, set that up based on the instructions in the jboss 3 manual or the quickstart guide after you have a simple configuration working.</P>
<P ALIGN=CENTER><FONT SIZE=4 STYLE="font-size: 16pt">8- Using the
Driver with </FONT><FONT SIZE=5>Tomcat</FONT></P>
<P><BR><BR>
</P>
<P>CATALINA_HOME is the installation directory for Tomcat 4.x or
greater. An environment variable of that name is set up on the Tomcat
server. TOMCAT_HOME was used in versions before Tomcat 4.</P>
<P>To use the driver with Tomcat You must put the jar files where
your web apps can access them. Once they are available to you web
apps you use the driver in your servlets or beans just as you would
in standalone programs.</P>
<P>If you have only one webapp using the drivers or you need to keep
the drivers separate from other web apps, put the jar files in the
WEB-INF/lib/ subdirectory of your web app.</P>
<P>It is more likely that Firebird will be used by all of your web
apps and Tomcat itself. To have universal access to the drivers put
the jars in CATALINA_HOME/common/lib/.</P>
<P>If you configure a JNDI entry in CATALINA_HOME/conf/server.xml to
use FBDataSourceObjectFactory, and you configure DBCP connection
pooling (in Tomcat 4.1.x or greater) only one connection pool is
started for all web apps. However, some users have reported problems
with DBCP under certain circumstances.</P>
<P>To use the driver's internal connection pooling, you can configure
an FBWrapping Data Source for pooling just as you would in a stand
alone program. If you put a class for doing that in a servlet and
start it when Tomcat is initialized, you can share a pool among web
applications. If you do this take care to make it thread safe and
synchronize access to methods.</P>
<P>Tomcat can also use Firebird for BASIC or FORM based user
authentication. See the Tomcat docs for more details. An example
realm for this is listed below. This goes in the
CATALINA_HOME/conf/server.xml file.</P>
<P><FONT FACE="Courier, monospace">&lt;Realm
className=&quot;org.apache.catalina.realm.JDBCRealm&quot; debug=&quot;0&quot;
</FONT>
</P>
<P><FONT FACE="Courier, monospace">driverName=&quot;org.firebirdsql.jdbc.FBDriver&quot;
</FONT>
</P>
<P><FONT FACE="Courier, monospace">userNameCol=&quot;USER_NAME&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">connectionName=&quot;sysdba&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">userTable=&quot;USERS&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">userCredCol=&quot;USER_PASS&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">validate=&quot;true&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">connectionURL=&quot;jdbc:firebirdsql:localhost/3050:/dir1/subdir/usersdb.gdb&quot;
</FONT>
</P>
<P><FONT FACE="Courier, monospace">userRoleTable=&quot;USER_ROLES&quot;
</FONT>
</P>
<P><FONT FACE="Courier, monospace">roleNameCol=&quot;ROLE_NAME&quot; </FONT>
</P>
<P><FONT FACE="Courier, monospace">connectionPassword=&quot;masterkey&quot;/&gt;</FONT></P>
<P>If your web app is set up to allow Tomcat to authenticate users
this tells Tomcat to use Firebird to look up user names ans
passwords. It does this by calling the Firebird driver FBDriver to
login to a database named usersdb.gdb located on localhost in the
directory /dir/subdir/, using the username sysdba and the password
masterkey.</P>
<P>Tomcat then takes the username that is typed into the browser by
the person logging into the web app and searches the table named
USERS to see if it is in the field USER_NAME of a record. If it is,
it checks to see if the password typed into the browser is the same
as the one in the field USER_PASS for that record. If it is, the user
is allowed to login and Tomcat opens the table USER_ROLES and
searches for all entries with USER_NAME. For each record it finds, it
looks in the ROLE_NAME column and adds that role name to a list of
roles for the user. It then allows access to web apps based on the
roles listed by the database.</P>
<P>You can configure your web apps in WEB-INF/web.xml to only allow
users with certain roles access to the web app. You can even use the
role inside your JSP's to only draw certain parts of an HTML page if
a user has the appropriate role. This alows you to customize each
page based on a user's role.</P>
<P>To use Tomcat's online GUI management web app to control your
Tomcat installation, you must have the role &quot;manager&quot; in
the USER_ROLES table under your name.</P>
<P>See the Tomcat docs for more information.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>9. Using the Pure Java JCA-JDBC Firebird
Driver with JBuilder 6 Personal</FONT></P>
<P ALIGN=CENTER>Last updated: 2002.04.11</P>
<P><BR><BR>
</P>
<P>Thanks to Marcelo Lopez Ruiz for this section.</P>
<P><BR><BR>
</P>
<P>If you have any comments/suggestions, drop me an mail at
marcelo.lopezruiz@xlnet.com.ar. If you have some spare time, check
out the rest of the site at
http://www.xlprueba.com.ar/marce/index.htm. 
</P>
<P><BR><BR>
</P>
<P>1. First, download the .zip file from SourceForge and unzip it to
a temporary directory.</P>
<P>2. Read the release_notes.html document.</P>
<P>3. Unless you are doing funny things with your JDK, you use the
default JDK installed with JBuilder6. In this case, you will need to
download the javax.sql.* package, named the JDBC 2.0 Optional Package
API (formerly known as the JDBC 2.0 Standard Extension API) from Sun,
at http://java.sun.com/products/jdbc/download.html. Select the last
option (option package binary), accept the license agreement, and
download the .jar file. 
</P>
<P>4. Start JBuilder 6 Personal. 
</P>
<P>5. Create a new project (File | New Project...). Select a
directory and a project name, then click Next. In step 2, select the
Required Libraries tab - here, the required libraries will be
registered with JBuilder and then added to the project.</P>
<P>6. Click the Add button. A list of libraries JBuilder is aware of
will be shown. Click the New button to register the required
libraries. Enter FireBird JCA-JDBC in the Name field, select JBuilder
in the Location combo box, and click the Add button. Select the
firebirdsql.jar you unzipped, and click OK. Click OK again to close
the library. Verify that the new library is selected, and click OK to
close the &quot;Select One or More Libraries&quot; dialog box.</P>
<P>7. Repeat the previous steps with the following libraries, found
in the lib subdirectory of the binary distribution (except for the
last package, which you downloaded from Sun). 
</P>
<P>concurrent.jar, named Concurrency Utilities 
</P>
<P>connector.jar, named Connector 
</P>
<P>jta-spec1_0_1.jar, named Java Transaction API 
</P>
<P>jdbc2_0-stdext.jar, named JDBC 2 Optional Package 
</P>
<P><BR><BR>
</P>
<P>8. Click Next, enter the desired project information, and click
Finish. 
</P>
<P>9. Create a new application (File | New, then Application in the
New tab). Enter the information you want for your application, and
complete the wizard. 
</P>
<P>10. Click on the Design tab, and double-click on the button with
the opening folder icon to create an event handler. 
</P>
<P>11. Type the following code for the event handler (note the small
helper method above). 
</P>
<P>p<FONT FACE="Courier, monospace">rivate void feedback(String text)
{</FONT></P>
<P><FONT FACE="Courier, monospace">statusBar.setText(text);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">void
jButton1_actionPerformed(ActionEvent e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// Hard-coded parameters</FONT></P>
<P><FONT FACE="Courier, monospace">String pathToDatabase =
&quot;C:\\Program Files\\Firebird\\examples\\EMPLOYEE.GDB&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String userName = &quot;sysdba&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String password = &quot;masterkey&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String sql = &quot;SELECT * FROM
EMPLOYEE&quot;;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Load the FireBird driver.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">Class.forName(&quot;org.firebirdsql.jdbc.FBDriver&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">} catch(ClassNotFoundException
cnfe) {</FONT></P>
<P><FONT FACE="Courier, monospace">feedback(&quot;org.firebirdsql.jdbc.FBDriver
not found&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Retrieve a connection.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">Statement stmt = null;</FONT></P>
<P><FONT FACE="Courier, monospace">ResultSet rst = null;</FONT></P>
<P><FONT FACE="Courier, monospace">Connection conn =
DriverManager.getConnection(</FONT></P>
<P><FONT FACE="Courier, monospace">&quot;jdbc:firebirdsql:localhost/3050:&quot;
+ pathToDatabase, userName, password);</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">// Create a statement and retrieve
its result set.</FONT></P>
<P><FONT FACE="Courier, monospace">stmt = conn.createStatement();</FONT></P>
<P><FONT FACE="Courier, monospace">rst = stmt.executeQuery(sql);</FONT></P>
<P><FONT FACE="Courier, monospace">// Show the result set through the
standard output.</FONT></P>
<P><FONT FACE="Courier, monospace">int columnCount =
rst.getMetaData().getColumnCount();</FONT></P>
<P><FONT FACE="Courier, monospace">int recordIndex = 0;</FONT></P>
<P><FONT FACE="Courier, monospace">while(rst.next()) {</FONT></P>
<P><FONT FACE="Courier, monospace">recordIndex++;</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println(&quot;Record: &quot;
+ recordIndex);</FONT></P>
<P><FONT FACE="Courier, monospace">for (int i=1;i&lt;=columnCount;i++)
{</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.print(rst.getMetaData().getColumnName(i));</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.print(&quot;: &quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println(rst.getString(i));</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">} finally {</FONT></P>
<P><FONT FACE="Courier, monospace">// close the database resources
immediately, rather than waiting</FONT></P>
<P><FONT FACE="Courier, monospace">// for the finalizer to kick in
later</FONT></P>
<P><FONT FACE="Courier, monospace">if (rst != null) rst.close();</FONT></P>
<P><FONT FACE="Courier, monospace">if (stmt != null) stmt.close();</FONT></P>
<P><FONT FACE="Courier, monospace">conn.close();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">} catch(SQLException se) {</FONT></P>
<P><FONT FACE="Courier, monospace">feedback(se.toString());</FONT></P>
<P><FONT FACE="Courier, monospace">se.printStackTrace();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P>12. Type the following code at the beginning of the file, after
the import statements. 
</P>
<P>import java.sql.*;</P>
<P>13. Run the application, click the button, and view the output. 
</P>
<P>14. For the morbidly curious, the following link provides an
overview of the classes offered by the concurrent.jar package.</P>
<P>http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html
</P>
<P>15. When using this library, note that there are still
unimplemented things. To view the source for the Connection class and
check which methods will return null values or an unimplemented
exception, see the following URL.
http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/firebird/client-java/src/org/firebirdsql/jdbc/FBConnection.java?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>10- Using Blobs</FONT></P>
<P><BR><BR>
</P>
<P>Blobs are Binary Large OBjects. Blobs are used to store blocks of
binary data of varying size in the database. An example would be a
database table to store gif or jpeg images for a photo album program.
Such a program could be written using the database to store file
names of image files to be loaded from disk, but this could easily be
corrupted if a file name were changed, a file inadvertently deleted,
or the database moved to a system with different file naming
conventions.</P>
<P>Blobs allow the binary image data to be stored, retrieved, backed
up, and migrated like any other database data.</P>
<P>The Interclient JDBC driver did not implement many of the blob
handling methods in the JDBC interfaces. So, the programmer had
limited tools for using blobs with Interclient. That is no longer the
case with the JCA-JDBC driver. If you come across old code or help
files dealing with blobs and Interbase/Interclient, be aware that it
may be outdated and easier ways of dealing with blobs are available
with the JCA-JDBC Driver.</P>
<P>Firebird BLOB fields are accessed through different JDBC
interfaces depending on their subtype. For subtype &lt;0, they are
accessed as Blob fields. Subtype 1 is a LongVarChar, and Subtype 2 is
LongVarBinary.</P>
<P>Below is some example code written for use with Interclient that
may be helpful.</P>
<P><FONT SIZE=4>Storing BLOB Data:</FONT></P>
<P>The example given below shows a method that inserts an array of
bytes into a BLOB column in the database. The PreparedStatement class
is used so we can set the parameters independant of the actual SQL
command string. 
</P>
<P>Inserting a BLOB 
</P>
<P><FONT FACE="Courier, monospace">import java.io.*;</FONT></P>
<P><FONT FACE="Courier, monospace">import java.sql.*;</FONT></P>
<P><FONT FACE="Courier, monospace">...</FONT></P>
<P><FONT FACE="Courier, monospace">public void insertBlob( int rowid,
byte[] bindata ) {</FONT></P>
<P><FONT FACE="Courier, monospace">// In this example I'm assuming
there's an open, active</FONT></P>
<P><FONT FACE="Courier, monospace">// Connection instance called
'con'.</FONT></P>
<P><FONT FACE="Courier, monospace">// This examples uses an imaginary
SQL table of the following</FONT></P>
<P><FONT FACE="Courier, monospace">// form:</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// CREATE TABLE blobs (</FONT></P>
<P><FONT FACE="Courier, monospace">// ROWID INT NOT NULL,</FONT></P>
<P><FONT FACE="Courier, monospace">// ROWDATA BLOB,</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// PRIMARY KEY (rowid)</FONT></P>
<P><FONT FACE="Courier, monospace">// );</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">ByteArrayInputStream bais = new
ByteArrayInputStream(bindata);</FONT></P>
<P><FONT FACE="Courier, monospace">String sql = &quot;INSERT INTO
blobs ( rowid, rowdata ) VALUES ( ?, ? )&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">PreparedStatement ps =
con.prepareStatement(sql);</FONT></P>
<P><FONT FACE="Courier, monospace">// Set up the parameter index for
convenience (JDBC column</FONT></P>
<P><FONT FACE="Courier, monospace">// indices start from 1):</FONT></P>
<P><FONT FACE="Courier, monospace">int paramindex = 1;</FONT></P>
<P><FONT FACE="Courier, monospace">// Set the first parameter, the
Row ID: </FONT>
</P>
<P><FONT FACE="Courier, monospace">ps.setInt(paramindex++, rowid);</FONT></P>
<P><FONT FACE="Courier, monospace">// Now set the actual binary
column data by passing the</FONT></P>
<P><FONT FACE="Courier, monospace">// ByteArrayInputStream instance
and its length:</FONT></P>
<P><FONT FACE="Courier, monospace">ps.setBinaryStream(paramindex++,
bais, bindata.length);</FONT></P>
<P><FONT FACE="Courier, monospace">// Finally, execute the command
and close the statement:</FONT></P>
<P><FONT FACE="Courier, monospace">ps.executeUpdate();</FONT></P>
<P><FONT FACE="Courier, monospace">ps.close();</FONT></P>
<P><FONT FACE="Courier, monospace">} catch ( SQLException se ) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.err.println(&quot;Couldn't
insert binary data: &quot;+se);</FONT></P>
<P><FONT FACE="Courier, monospace">} catch ( IOException ioe ) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.err.println(&quot;Couldn't
insert binary data: &quot;+ioe);</FONT></P>
<P><FONT FACE="Courier, monospace">} finally {</FONT></P>
<P><FONT FACE="Courier, monospace">con.close();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT SIZE=4>Retrieving BLOB Data:</FONT></P>
<P>The example given below shows a method that retrieves an array of
bytes from the database. 
</P>
<P>Selecting a BLOB 
</P>
<P><FONT FACE="Courier, monospace">import java.io.*;</FONT></P>
<P><FONT FACE="Courier, monospace">import java.sql.*;</FONT></P>
<P><FONT FACE="Courier, monospace">...</FONT></P>
<P><FONT FACE="Courier, monospace">public byte[] selectBlob( int
rowid ) {</FONT></P>
<P><FONT FACE="Courier, monospace">// In this example I'm assuming
there's an open, active</FONT></P>
<P><FONT FACE="Courier, monospace">// Connection instance called
'con'.</FONT></P>
<P><FONT FACE="Courier, monospace">// This examples uses an imaginary
SQL table of the following</FONT></P>
<P><FONT FACE="Courier, monospace">// form:</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// CREATE TABLE blobs (</FONT></P>
<P><FONT FACE="Courier, monospace">// ROWID INT NOT NULL,</FONT></P>
<P><FONT FACE="Courier, monospace">// ROWDATA BLOB,</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// PRIMARY KEY (rowid)</FONT></P>
<P><FONT FACE="Courier, monospace">// );</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">Statement sment =
con.createStatement();</FONT></P>
<P><FONT FACE="Courier, monospace">String sql = &quot;SELECT rowid,
rowdata FROM blobs WHERE rowid = &quot; + rowid;</FONT></P>
<P><FONT FACE="Courier, monospace">ResultSet rs =
sment.executeQuery(sql);</FONT></P>
<P><FONT FACE="Courier, monospace">byte[] returndata = null;</FONT></P>
<P><FONT FACE="Courier, monospace">if ( rs.next() ) {</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">// The ByteArrayOutputStream
buffers all bytes written to it</FONT></P>
<P><FONT FACE="Courier, monospace">// until we call getBytes() which
returns to us an array of bytes:</FONT></P>
<P><FONT FACE="Courier, monospace">ByteArrayOutputStream baos = new
ByteArrayOutputStream(1024);</FONT></P>
<P><FONT FACE="Courier, monospace">// Create an input stream from the
BLOB column. By default, rs.getBinaryStream()</FONT></P>
<P><FONT FACE="Courier, monospace">// returns a vanilla InputStream
instance. We override this for efficiency</FONT></P>
<P><FONT FACE="Courier, monospace">// but you don't have to:</FONT></P>
<P><FONT FACE="Courier, monospace">BufferedInputStream bis = new
BufferedInputStream( rs.getBinaryStream(&quot;fieldblob&quot;) );</FONT></P>
<P><FONT FACE="Courier, monospace">// A temporary buffer for the byte
data:</FONT></P>
<P><FONT FACE="Courier, monospace">byte bindata[1024];</FONT></P>
<P><FONT FACE="Courier, monospace">// Used to return how many bytes
are read with each read() of the input stream:</FONT></P>
<P><FONT FACE="Courier, monospace">int bytesread = 0;</FONT></P>
<P><FONT FACE="Courier, monospace">// Make sure its not a NULL value
in the column:</FONT></P>
<P><FONT FACE="Courier, monospace">if ( !rs.wasNull() ) {</FONT></P>
<P><FONT FACE="Courier, monospace">if ( (bytesread =
bis.read(bindata,0,bindata.length)) != -1 ) {</FONT></P>
<P><FONT FACE="Courier, monospace">// Write out 'bytesread' bytes to
the writer instance:</FONT></P>
<P><FONT FACE="Courier, monospace">baos.write(bindata,0,bytesread);</FONT></P>
<P><FONT FACE="Courier, monospace">} else {</FONT></P>
<P><FONT FACE="Courier, monospace">// When the read() method returns
-1 we've hit the end of the stream,</FONT></P>
<P><FONT FACE="Courier, monospace">// so now we can get our bytes out
of the writer object:</FONT></P>
<P><FONT FACE="Courier, monospace">returndata = baos.getBytes();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">// Close the binary input stream:</FONT></P>
<P><FONT FACE="Courier, monospace">bis.close();</FONT></P>
<P><FONT FACE="Courier, monospace">} catch ( IOException ioe ) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.err.println(&quot;Problem
retrieving binary data: &quot; + ioe);</FONT></P>
<P><FONT FACE="Courier, monospace">} catch ( ClassNotFoundException
cnfe ) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.err.println(&quot;Problem
retrieving binary data: &quot; + cnfe);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">rs.close();</FONT></P>
<P><FONT FACE="Courier, monospace">sment.close();</FONT></P>
<P><FONT FACE="Courier, monospace">} catch ( SQLException se ) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.err.println(&quot;Couldn't
retrieve binary data: &quot; + se);</FONT></P>
<P><FONT FACE="Courier, monospace">} finally {</FONT></P>
<P><FONT FACE="Courier, monospace">con.close();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">return returndata;</FONT></P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>11- Using Multi-Byte Character Sets</FONT></P>
<P><BR><BR>
</P>
<P>Character Encodings:</P>
<P>Support for character encodings has just been added. This is
easily accessible only from the FBDriver class. To use it, request a
connection with a properties object containing a name-value pair
lc_ctype=WIN1250 or other appropriate encoding name.</P>
<P>URL-encoded params are fully supported only when you get a
connection from java.sql.DriverManager (using FBDriver class). For
example:
jdbc:firebirdsql://localhost//home/databases/sample.gdb?lc_ctype=UNICODE_FSS</P>
<P>It is also possible to set lc_ctype in a deployment descriptor by
adding the following to your deployment descriptor:</P>
<P><FONT FACE="Courier, monospace">&lt;config-property&gt;</FONT></P>
<P><FONT FACE="Courier, monospace">&lt;config-property-name&gt;Encoding&lt;/config-property-name&gt;</FONT></P>
<P><FONT FACE="Courier, monospace">&lt;config-property-type&gt;java.lang.String&lt;/config-property-type&gt;</FONT></P>
<P><FONT FACE="Courier, monospace">&lt;config-property-value&gt;UNICODE_FSS&lt;/config-property-value&gt;</FONT></P>
<P><FONT FACE="Courier, monospace">&lt;/config-property&gt;</FONT></P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>12- Reporting Bugs</FONT></P>
<P><BR><BR>
</P>
<P>The developers attempt to follow the Firebird-Java@yahoogroups.com
list. Join the list (see #16 below) and post information about
suspected bugs. This is a good idea because what is often thought to
be a bug turns out to be something else. List members may be able o
help out and get you going again, whereas bug fixes might take
awhile.</P>
<P>You may also report bugs in the firebird bugtracker at:</P>
<P>http://sourceforge.net/tracker/?group_id=9028&amp;atid=109028</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>13- Obtaining Sources From SourceForge
using CVS</FONT></P>
<P ALIGN=CENTER><BR><BR>
</P>
<P>CVS is a source code control system for managing access to, and
synchronizing source code in a project that is being developed by
multiple programmers. A full explanation of CVS is beyond the scope
of this document, but information is available at sorceforge.net.</P>
<P>To get the project containing the source from sourceforge, install
CVS on your system and use it to download the module named
&quot;client-java&quot;. The user name is &quot;anonymous&quot;.</P>
<P>To build the source you will need several programs installed on
your system. One is Ant which can be downloaded from
http://jakarta.apache.org/ant/index.html.</P>
<P>Ant is a Java based build tool, similar to &ldquo;make&rdquo; on
Unix systems, that uses xml files as its input containing
instructions for building a project.</P>
<P>Ant, of course, requires that Java be installed on your system.</P>
<P>If you use a GUI based CVS tool like WinCVS on Windows, be sure
that you also have your system set up to run CVS from the command
line.</P>
<P>This is necessary because the newest version of the driver uses
libraries from the JBoss project to avoid licensing issues related to
distributing some libraries from Sun. The Ant build scripts use
command line CVS to &ldquo;check out&rdquo; the code needed from the
JBoss project.</P>
<P>Once you install these tools and download the source, you should
be able to go into the client-java folder (wherever you had CVS put
it) and type &quot;build&quot; from the command line to build the
driver.</P>
<P>There is a file in the client-java directory called &quot;build.bat&quot;
for Windows systems and one called &quot;build.sh&quot; for Unix
systems. Under certain Unix shells you will have to type &quot;build.sh&quot;
from the command line, the csh under Solaris, for example.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>14- Participating in the Development
Project</FONT></P>
<P><BR><BR>
</P>
<P>Use the Firebird-Java@yahoogroups.com list to contact the
developers about helping out (see #16 below). Perhaps the most
crucial need right now is for more and better setup and usage guides,
and to produce a reasonable section of the Firebird web site devoted
to this driver. Work on this would be greatly appreciated.</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>15- Where to get help</FONT></P>
<P><BR><BR>
</P>
<P>The Firebird-Java mail list: Firebird-Java@yahoogroups.com (see
#16 below).</P>
<P>The code for Firebird and this driver are on <A HREF="http://www.sourceforge.net/">www.sourceforge.net</A>
under the Firebird project.</P>
<P>The Firebird web site: <A HREF="http://www.IBPhoenix.com/">www.IBPhoenix.com</A></P>
<P>The Sun Java web site: <A HREF="http://java.sun.com/">java.sun.com</A></P>
<P>The Jboss web site: <A HREF="http://www.jboss.org/">www.jboss.org</A></P>
<P>The Jakarta Project Web Site for Ant and Tomcat:
<A HREF="http://jakarta.apache.org/">jakarta.apache.org</A></P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>16- Joining the Mailing List</FONT></P>
<P><BR><BR>
</P>
<P>To join the Firebird-java mailing list, go to www.yahoogroups.com.
Follow the instructions there for joining a group. The name of the
group is Firebird-java.</P>
<P>Please set your Yahoo settings to use plain text instead of HTML.
All the ads drive some folks nuts and cause an automatic internet
hookup for some folks in Europe who have to pay for outgoing phone
calls.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>17- Known Bugs</FONT></P>
<P><BR><BR>
</P>
<OL>
	<LI><P>The driver does not work properly with some non-JBoss J2EE
	containers.</P>
	<P>Work is underway to correct this. Monitor SourceForge and the
	mail list for updates.</P>
</OL>
<P>You may report bugs in the firebird bugtracker at
http://sourceforge.net/tracker/?group_id=9028&amp;atid=109028 
</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>18- Additional JAR Libraries Needed to
Use the Driver</FONT></P>
<P><BR><BR>
</P>
<P>mini-j2ee.jar</P>
<P>mini-concurrent.jar</P>
<P>jaas.jar (with jdk 1.4)</P>
<P>log4j-core.jar (if you want logging available).</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>19- Code Examples</FONT></P>
<P ALIGN=CENTER><BR><BR>
</P>
<P>There are two examples below, a driver example and a DataSource
example.</P>
<P><FONT SIZE=4>Driver Example:</FONT></P>
<P><FONT FACE="Courier, monospace">// Original version of this file
was part of InterClient 2.01 examples</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Copyright InterBase Software
Corporation, 1998.</FONT></P>
<P><FONT FACE="Courier, monospace">// Written by
com.inprise.interbase.interclient.r&amp;d.PaulOstler :-)</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Code was modified by Roman
Rokytskyy to show that Firebird JCA-JDBC driver</FONT></P>
<P><FONT FACE="Courier, monospace">// does not introduce additional
complexity in normal driver usage scenario.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// A small application to
demonstrate basic, but not necessarily simple, JDBC features.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Note: you will need to hardwire
the path to your copy of employee.gdb</FONT></P>
<P><FONT FACE="Courier, monospace">// as well as supply a
user/password in the code below at the</FONT></P>
<P><FONT FACE="Courier, monospace">// beginning of method main().</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">public class DriverExample</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">// Make a connection to an
employee.gdb on your local machine,</FONT></P>
<P><FONT FACE="Courier, monospace">// and demonstrate basic JDBC
features.</FONT></P>
<P><FONT FACE="Courier, monospace">// Notice that main() uses its own
local variables rather than</FONT></P>
<P><FONT FACE="Courier, monospace">// static class variables, so it
need not be synchronized.</FONT></P>
<P><FONT FACE="Courier, monospace">public static void main (String
args[]) throws Exception</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">// Modify the following hardwired
settings for your environment.</FONT></P>
<P><FONT FACE="Courier, monospace">// Note: localhost is a TCP/IP
keyword which resolves to your local machine's IP address.</FONT></P>
<P><FONT FACE="Courier, monospace">// If localhost is not recognized,
try using your local machine's name or</FONT></P>
<P><FONT FACE="Courier, monospace">// the loopback IP address
127.0.0.1 in place of localhost.</FONT></P>
<P><FONT FACE="Courier, monospace">String databaseURL =
&quot;jdbc:firebirdsql:localhost/3050:c:/database/employee.gdb&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String user = &quot;sysdba&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String password = &quot;masterkey&quot;;</FONT></P>
<P><FONT FACE="Courier, monospace">String driverName =
&quot;org.firebirdsql.jdbc.FBDriver&quot;;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// As an exercise to the reader,
add some code which extracts databaseURL,</FONT></P>
<P><FONT FACE="Courier, monospace">// user, and password from the
program args[] to main().</FONT></P>
<P><FONT FACE="Courier, monospace">// As a further exercise, allow
the driver name to be passed as well,</FONT></P>
<P><FONT FACE="Courier, monospace">// and modify the code below to
use driverName rather than the hardwired</FONT></P>
<P><FONT FACE="Courier, monospace">// string
&quot;org.firebirdsql.jdbc.FBDriver&quot; so that this code becomes</FONT></P>
<P><FONT FACE="Courier, monospace">// driver independent. However,
the code will still rely on the</FONT></P>
<P><FONT FACE="Courier, monospace">// predefined table structure of
employee.gdb.</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// See comment about closing JDBC
objects at the end of this main() method.</FONT></P>
<P><FONT FACE="Courier, monospace">System.runFinalizersOnExit (true);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Here are the JDBC objects we're
going to work with.</FONT></P>
<P><FONT FACE="Courier, monospace">// We're defining them outside the
scope of the try block because</FONT></P>
<P><FONT FACE="Courier, monospace">// they need to be visible in a
finally clause which will be used</FONT></P>
<P><FONT FACE="Courier, monospace">// to close everything when we are
done.</FONT></P>
<P><FONT FACE="Courier, monospace">// The finally clause will be
executed even if an exception occurs.</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.Driver d = null;</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.Connection c = null;</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.Statement s = null;</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.ResultSet rs = null;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Any return from this try block
will first execute the finally clause</FONT></P>
<P><FONT FACE="Courier, monospace">// towards the bottom of this
file.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Let's try to register the
Firebird JCA-JDBC driver with the driver manager</FONT></P>
<P><FONT FACE="Courier, monospace">// using one of various
registration alternatives...</FONT></P>
<P><FONT FACE="Courier, monospace">int registrationAlternative = 1;</FONT></P>
<P><FONT FACE="Courier, monospace">switch (registrationAlternative) {</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">case 1:</FONT></P>
<P><FONT FACE="Courier, monospace">// This is the standard
alternative and simply loads the driver class.</FONT></P>
<P><FONT FACE="Courier, monospace">// Class.forName() instructs the
java class loader to load</FONT></P>
<P><FONT FACE="Courier, monospace">// and initialize a class. As part
of the class initialization</FONT></P>
<P><FONT FACE="Courier, monospace">// any static clauses associated
with the class are executed.</FONT></P>
<P><FONT FACE="Courier, monospace">// Every driver class is required
by the jdbc specification to automatically</FONT></P>
<P><FONT FACE="Courier, monospace">// create an instance of itself
and register that instance with the driver</FONT></P>
<P><FONT FACE="Courier, monospace">// manager when the driver class
is loaded by the java class loader</FONT></P>
<P><FONT FACE="Courier, monospace">// (this is done via a static
clause associated with the driver class).</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Notice that the driver name
could have been supplied dynamically,</FONT></P>
<P><FONT FACE="Courier, monospace">// so that an application is not
hardwired to any particular driver</FONT></P>
<P><FONT FACE="Courier, monospace">// as would be the case if a
driver constructor were used, eg.</FONT></P>
<P><FONT FACE="Courier, monospace">// new
org.firebirdsql.jdbc.FBDriver().</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">Class.forName
(&quot;org.firebirdsql.jdbc.FBDriver&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch
(java.lang.ClassNotFoundException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// A call to Class.forName()
forces us to consider this exception :-)...</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Firebird
JCA-JDBC driver not found in class path&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (e.getMessage
());</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">break;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">case 2:</FONT></P>
<P><FONT FACE="Courier, monospace">// There is a bug in some JDK 1.1
implementations, eg. with Microsoft</FONT></P>
<P><FONT FACE="Courier, monospace">// Internet Explorer, such that
the implicit driver instance created during</FONT></P>
<P><FONT FACE="Courier, monospace">// class initialization does not
get registered when the driver is loaded</FONT></P>
<P><FONT FACE="Courier, monospace">// with Class.forName().</FONT></P>
<P><FONT FACE="Courier, monospace">// See the FAQ at
http://java.sun.com/jdbc for more info on this problem.</FONT></P>
<P><FONT FACE="Courier, monospace">// Notice that in the following
workaround for this bug, that if the bug</FONT></P>
<P><FONT FACE="Courier, monospace">// is not present, then two
instances of the driver will be registered</FONT></P>
<P><FONT FACE="Courier, monospace">// with the driver manager, the
implicit instance created by the driver</FONT></P>
<P><FONT FACE="Courier, monospace">// class's static clause and the
one created explicitly with newInstance().</FONT></P>
<P><FONT FACE="Courier, monospace">// This alternative should not be
used except to workaround a JDK 1.1</FONT></P>
<P><FONT FACE="Courier, monospace">// implementation bug.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.DriverManager.registerDriver
(</FONT></P>
<P><FONT FACE="Courier, monospace">(java.sql.Driver) Class.forName
(&quot;org.firebirdsql.jdbc.FBDriver&quot;).newInstance ()</FONT></P>
<P><FONT FACE="Courier, monospace">);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch
(java.lang.ClassNotFoundException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// A call to Class.forName()
forces us to consider this exception :-)...</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Driver
not found in class path&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (e.getMessage
());</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch
(java.lang.IllegalAccessException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// A call to newInstance() forces
us to consider this exception :-)...</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to access driver constructor, this shouldn't happen!&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (e.getMessage
());</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch
(java.lang.InstantiationException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// A call to newInstance() forces
us to consider this exception :-)...</FONT></P>
<P><FONT FACE="Courier, monospace">// Attempt to instantiate an
interface or abstract class.</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to create an instance of driver class, this shouldn't happen!&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (e.getMessage
());</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">// A call to registerDriver()
forces us to consider this exception :-)...</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Driver
manager failed to register driver&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">break;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">case 3:</FONT></P>
<P><FONT FACE="Courier, monospace">// Add the Firebird JCA-JDBC
driver name to your system's jdbc.drivers property list.</FONT></P>
<P><FONT FACE="Courier, monospace">// The driver manager will load
drivers from this system property list.</FONT></P>
<P><FONT FACE="Courier, monospace">// System.getProperties() may not
be allowed for applets in some browsers.</FONT></P>
<P><FONT FACE="Courier, monospace">// For applets, use one of the
Class.forName() alternatives above.</FONT></P>
<P><FONT FACE="Courier, monospace">java.util.Properties sysProps =
System.getProperties ();</FONT></P>
<P><FONT FACE="Courier, monospace">StringBuffer drivers = new
StringBuffer (&quot;org.firebirdsql.jdbc.FBDriver&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">String oldDrivers =
sysProps.getProperty (&quot;jdbc.drivers&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">if (oldDrivers != null)</FONT></P>
<P><FONT FACE="Courier, monospace">drivers.append (&quot;:&quot; +
oldDrivers);</FONT></P>
<P><FONT FACE="Courier, monospace">sysProps.put (&quot;jdbc.drivers&quot;,
drivers.toString ());</FONT></P>
<P><FONT FACE="Courier, monospace">System.setProperties (sysProps);</FONT></P>
<P><FONT FACE="Courier, monospace">break;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">case 4:</FONT></P>
<P><FONT FACE="Courier, monospace">// Advanced: This is a
non-standard alternative, and is tied to</FONT></P>
<P><FONT FACE="Courier, monospace">// a particular driver
implementation, but is very flexible.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// It may be possible to configure
a driver explicitly, either thru</FONT></P>
<P><FONT FACE="Courier, monospace">// the use of non-standard driver
constructors, or non-standard</FONT></P>
<P><FONT FACE="Courier, monospace">// driver &quot;set&quot; methods
which somehow tailor the driver to behave</FONT></P>
<P><FONT FACE="Courier, monospace">// differently from the default
driver instance.</FONT></P>
<P><FONT FACE="Courier, monospace">// Under this alternative, a
driver instance is created explicitly</FONT></P>
<P><FONT FACE="Courier, monospace">// using a driver specific
constructor. The driver may then be</FONT></P>
<P><FONT FACE="Courier, monospace">// tailored differently from the
default driver instance which is</FONT></P>
<P><FONT FACE="Courier, monospace">// created automatically when the
driver class is loaded by the java class loader.</FONT></P>
<P><FONT FACE="Courier, monospace">// For example, perhaps a driver
instance could be created which</FONT></P>
<P><FONT FACE="Courier, monospace">// is to behave like some older
version of the driver.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// d = new
org.firebirdsql.jdbc.FBDriver ();</FONT></P>
<P><FONT FACE="Courier, monospace">// DriverManager.registerDriver
(d);</FONT></P>
<P><FONT FACE="Courier, monospace">// c = DriverManager.getConnection
(...);</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Since two drivers, with
differing behavior, are now registered with</FONT></P>
<P><FONT FACE="Courier, monospace">// the driver manager, they
presumably must recognize different jdbc</FONT></P>
<P><FONT FACE="Courier, monospace">// subprotocols. For example, the
tailored driver may only recognize</FONT></P>
<P><FONT FACE="Courier, monospace">//
&quot;jdbc:interbase:old_version://...&quot;, whereas the default
driver instance</FONT></P>
<P><FONT FACE="Courier, monospace">// would recognize the standard
&quot;jdbc:interbase://...&quot;.</FONT></P>
<P><FONT FACE="Courier, monospace">// There are currently no methods,
such as the hypothetical setVersion(),</FONT></P>
<P><FONT FACE="Courier, monospace">// for tailoring an Firebird
JCA-JDBC driver so this 4th alternative is academic</FONT></P>
<P><FONT FACE="Courier, monospace">// and not necessary for Firebird
JCA-JDBC driver.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// It is also possible to create a
tailored driver instance which</FONT></P>
<P><FONT FACE="Courier, monospace">// is *not* registered with the
driver manager as follows</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// d = new
org.firebirdsql.jdbc.FBDriver ();</FONT></P>
<P><FONT FACE="Courier, monospace">// c = d.connect (...);</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// this is the most usual case as
this does not require differing</FONT></P>
<P><FONT FACE="Courier, monospace">// jdbc subprotocols since the
connection is obtained thru the driver</FONT></P>
<P><FONT FACE="Courier, monospace">// directly rather than thru the
driver manager.</FONT></P>
<P><FONT FACE="Courier, monospace">d = new
org.firebirdsql.jdbc.FBDriver ();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// At this point the driver should
be registered with the driver manager.</FONT></P>
<P><FONT FACE="Courier, monospace">// Try to find the registered
driver that recognizes interbase URLs...</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">// We pass the entire database
URL, but we could just pass &quot;jdbc:interbase:&quot;</FONT></P>
<P><FONT FACE="Courier, monospace">d =
java.sql.DriverManager.getDriver (databaseURL);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Firebird
JCA-JDBC driver version &quot; +</FONT></P>
<P><FONT FACE="Courier, monospace">d.getMajorVersion () +</FONT></P>
<P><FONT FACE="Courier, monospace">&quot;.&quot; +</FONT></P>
<P><FONT FACE="Courier, monospace">d.getMinorVersion () +</FONT></P>
<P><FONT FACE="Courier, monospace">&quot; registered with driver
manager.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to find Firebird JCA-JDBC driver among the registered drivers.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Advanced info: Class.forName()
loads the java class for the driver.</FONT></P>
<P><FONT FACE="Courier, monospace">// All JDBC drivers are required
to have a static clause that automatically</FONT></P>
<P><FONT FACE="Courier, monospace">// creates an instance of
themselves and registers that instance</FONT></P>
<P><FONT FACE="Courier, monospace">// with the driver manager. So
there is no need to call</FONT></P>
<P><FONT FACE="Courier, monospace">// DriverManager.registerDriver()
explicitly unless the driver allows</FONT></P>
<P><FONT FACE="Courier, monospace">// for tailored driver instances
to be created (each instance recognizing</FONT></P>
<P><FONT FACE="Courier, monospace">// a different jdbc sub-protocol).</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Now that Firebird JCA-JDBC
driver is registered with the driver manager,</FONT></P>
<P><FONT FACE="Courier, monospace">// try to get a connection to an
employee.gdb database on this local machine</FONT></P>
<P><FONT FACE="Courier, monospace">// using one of two alternatives
for obtaining connections...</FONT></P>
<P><FONT FACE="Courier, monospace">int connectionAlternative = 1;</FONT></P>
<P><FONT FACE="Courier, monospace">switch (connectionAlternative) {</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">case 1:</FONT></P>
<P><FONT FACE="Courier, monospace">// This alternative is driver
independent;</FONT></P>
<P><FONT FACE="Courier, monospace">// the driver manager will find
the right driver for you based on the jdbc subprotocol.</FONT></P>
<P><FONT FACE="Courier, monospace">// In the past, this alternative
did not work with applets in some browsers because of a</FONT></P>
<P><FONT FACE="Courier, monospace">// bug in the driver manager. I
believe this has been fixed in the jdk 1.1 implementations.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">c =
java.sql.DriverManager.getConnection (databaseURL, user, password);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Connection
established.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to establish a connection through the driver manager.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">break;</FONT></P>
<P><FONT FACE="Courier, monospace">case 2:</FONT></P>
<P><FONT FACE="Courier, monospace">// If you're working with a
particular driver d, which may or may not be registered,</FONT></P>
<P><FONT FACE="Courier, monospace">// you can get a connection
directly from it, bypassing the driver manager...</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">java.util.Properties
connectionProperties = new java.util.Properties ();</FONT></P>
<P><FONT FACE="Courier, monospace">connectionProperties.put (&quot;user&quot;,
user);</FONT></P>
<P><FONT FACE="Courier, monospace">connectionProperties.put
(&quot;password&quot;, password);</FONT></P>
<P><FONT FACE="Courier, monospace">c = d.connect (databaseURL,
connectionProperties);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Connection
established.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to establish a connection through the driver.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">break;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Let's disable the default
autocommit so we can undo our changes later...</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">c.setAutoCommit (false);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Auto-commit
is disabled.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to disable autocommit.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Now that we have a connection,
let's try to get some meta data...</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.DatabaseMetaData
dbMetaData = c.getMetaData ();</FONT></P>
<P><FONT FACE="Courier, monospace">// Ok, let's query a
driver/database capability</FONT></P>
<P><FONT FACE="Courier, monospace">if
(dbMetaData.supportsTransactions ())</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Transactions
are supported.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">else</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Transactions
are not supported.&quot;);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// What are the views defined on
this database?</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.ResultSet tables =
dbMetaData.getTables (null, null, &quot;%&quot;, new String[]
{&quot;VIEW&quot;});</FONT></P>
<P><FONT FACE="Courier, monospace">while (tables.next ()) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println
(tables.getString (&quot;TABLE_NAME&quot;) + &quot; is a view.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">tables.close ();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to extract database meta data.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">// What the heck, who needs meta
data anyway ;-(, let's continue on...</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Let's try to submit some static
SQL on the connection.</FONT></P>
<P><FONT FACE="Courier, monospace">// Note: This SQL should throw an
exception on employee.gdb because</FONT></P>
<P><FONT FACE="Courier, monospace">// of an integrity constraint
violation. </FONT>
</P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">s = c.createStatement ();</FONT></P>
<P><FONT FACE="Courier, monospace">s.executeUpdate (&quot;update
employee set salary = salary + 10000&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to increase everyone's salary.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">// We expected this to fail, so
don't return, let's keep going...</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Let's submit some static SQL
which produces a result set.</FONT></P>
<P><FONT FACE="Courier, monospace">// Notice that the statement s is
reused with a new SQL string.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">rs = s.executeQuery (&quot;select
full_name from employee where salary &lt; 50000&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to submit a static SQL query.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">// We can't go much further
without a result set, return...</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// The query above could just as
easily have been dynamic SQL,</FONT></P>
<P><FONT FACE="Courier, monospace">// eg. if the SQL had been entered
as user input.</FONT></P>
<P><FONT FACE="Courier, monospace">// As a dynamic query, we'd need
to query the result set meta data</FONT></P>
<P><FONT FACE="Courier, monospace">// for information about the
result set's columns.</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.ResultSetMetaData
rsMetaData = rs.getMetaData ();</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;The
query executed has &quot; +</FONT></P>
<P><FONT FACE="Courier, monospace">rsMetaData.getColumnCount () +</FONT></P>
<P><FONT FACE="Courier, monospace">&quot; result columns.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Here are
the columns: &quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">for (int i = 1; i &lt;=
rsMetaData.getColumnCount (); i++) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println
(rsMetaData.getColumnName (i) +</FONT></P>
<P><FONT FACE="Courier, monospace">&quot; of type &quot; +</FONT></P>
<P><FONT FACE="Courier, monospace">rsMetaData.getColumnTypeName (i));</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to extract result set meta data.&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">// What the heck, who needs meta
data anyway ;-(, let's continue on...</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Ok, lets step thru the results
of the query...</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Here are
the employee's whose salary &lt; $50,000&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">while (rs.next ()) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (rs.getString
(&quot;full_name&quot;));</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Unable
to step thru results of query&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">showSQLException (e);</FONT></P>
<P><FONT FACE="Courier, monospace">return;</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// As an exercise to the reader,
rewrite this code so that required</FONT></P>
<P><FONT FACE="Courier, monospace">// table structures are created
dynamically using executeUpdate() on DDL.</FONT></P>
<P><FONT FACE="Courier, monospace">// In this way the code will be
able to run against any database file rather</FONT></P>
<P><FONT FACE="Courier, monospace">// than just a previously setup
employee.gdb.</FONT></P>
<P><FONT FACE="Courier, monospace">// Just to get you started, you'll
want to define a method something like</FONT></P>
<P><FONT FACE="Courier, monospace">// the following...</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// private static void
createTableStructures (java.sql.Connection c) throws
java.sql.SQLException</FONT></P>
<P><FONT FACE="Courier, monospace">// {</FONT></P>
<P><FONT FACE="Courier, monospace">// // Some drivers don't force
commit on DDL, Firebird JCA-JDBC driver does,</FONT></P>
<P><FONT FACE="Courier, monospace">// // see
DatabaseMetaData.dataDefinitionCausesTransactionCommit().</FONT></P>
<P><FONT FACE="Courier, monospace">// // This is not necessary for
Firebird JCA-JDBC driver, but may be for other drivers...</FONT></P>
<P><FONT FACE="Courier, monospace">// c.setAutoCommit (true);</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// java.sql.Statement s =
c.createStatement();</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// // Drop table EMPLOYEE if it
already exists, if not that's ok too.</FONT></P>
<P><FONT FACE="Courier, monospace">// try { s.executeUpdate (&quot;drop
table EMPLOYEE&quot;); } catch (java.sql.SQLException e) {}</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// // Ok, now that we're sure the
table isn't already there, create it...</FONT></P>
<P><FONT FACE="Courier, monospace">// s.executeUpdate (&quot;create
table EMPLOYEE (...)&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// // Ok, now populate the
EMPLOYEE table...</FONT></P>
<P><FONT FACE="Courier, monospace">// s.executeUpdate (&quot;insert
into EMPLOYEE values (...)&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// s.close();</FONT></P>
<P><FONT FACE="Courier, monospace">// c.setAutoCommit (false);</FONT></P>
<P><FONT FACE="Courier, monospace">// }</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// This finally clause will be
executed even if &quot;return&quot; was called in case of any
exceptions above.</FONT></P>
<P><FONT FACE="Courier, monospace">finally {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Closing
database resources and rolling back any changes we made to the
database.&quot;);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Now that we're all finished,
let's release database resources.</FONT></P>
<P><FONT FACE="Courier, monospace">try { if (rs!=null) rs.close (); }
catch (java.sql.SQLException e) { showSQLException (e); }</FONT></P>
<P><FONT FACE="Courier, monospace">try { if (s!=null) s.close (); }
catch (java.sql.SQLException e) { showSQLException (e); }</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Before we close the connection,
let's rollback any changes we may have made.</FONT></P>
<P><FONT FACE="Courier, monospace">try { if (c!=null) c.rollback ();
} catch (java.sql.SQLException e) { showSQLException (e); }</FONT></P>
<P><FONT FACE="Courier, monospace">try { if (c!=null) c.close (); }
catch (java.sql.SQLException e) { showSQLException (e); }</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// If you don't close your
database objects explicitly as above,</FONT></P>
<P><FONT FACE="Courier, monospace">// they may be closed by the
object's finalizer, but there's</FONT></P>
<P><FONT FACE="Courier, monospace">// no guarantee if or when the
finalizer will be called.</FONT></P>
<P><FONT FACE="Courier, monospace">// In general, object finalizers
are not called on program exit.</FONT></P>
<P><FONT FACE="Courier, monospace">// It's recommended to close your
JDBC objects explictly,</FONT></P>
<P><FONT FACE="Courier, monospace">// but you can use
System.runFinalizersOnExit(true), as at the beginning</FONT></P>
<P><FONT FACE="Courier, monospace">// of this method main(), to force
finalizers to be called before</FONT></P>
<P><FONT FACE="Courier, monospace">// program exit.</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Display an SQLException which
has occured in this application.</FONT></P>
<P><FONT FACE="Courier, monospace">private static void
showSQLException (java.sql.SQLException e)</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">// Notice that a SQLException is
actually a chain of SQLExceptions,</FONT></P>
<P><FONT FACE="Courier, monospace">// let's not forget to print all
of them...</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.SQLException next = e;</FONT></P>
<P><FONT FACE="Courier, monospace">while (next != null) {</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println
(next.getMessage ());</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;Error
Code: &quot; + next.getErrorCode ());</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;SQL
State: &quot; + next.getSQLState ());</FONT></P>
<P><FONT FACE="Courier, monospace">next = next.getNextException ();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P><FONT SIZE=4>Data Source Example:</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Original version of this file
was part of InterClient 2.01 examples</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Copyright InterBase Software
Corporation, 1998.</FONT></P>
<P><FONT FACE="Courier, monospace">// Written by
com.inprise.interbase.interclient.r&amp;d.PaulOstler :-)</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// Code was modified by Roman
Rokytskyy to show that Firebird JCA-JDBC driver</FONT></P>
<P><FONT FACE="Courier, monospace">// does not introduce additional
complexity in normal driver usage scenario.</FONT></P>
<P><FONT FACE="Courier, monospace">//</FONT></P>
<P><FONT FACE="Courier, monospace">// An example of using a JDBC 2
Standard Extension DataSource.</FONT></P>
<P><FONT FACE="Courier, monospace">// The DataSource facility
provides an alternative to the JDBC DriverManager,</FONT></P>
<P><FONT FACE="Courier, monospace">// essentially duplicating all of
the driver manager&rsquo;s useful functionality.</FONT></P>
<P><FONT FACE="Courier, monospace">// Although, both mechanisms may
be used by the same application if desired,</FONT></P>
<P><FONT FACE="Courier, monospace">// JavaSoft encourages developers
to regard the DriverManager as a legacy</FONT></P>
<P><FONT FACE="Courier, monospace">// feature of the JDBC API.</FONT></P>
<P><FONT FACE="Courier, monospace">// Applications should use the
DataSource API whenever possible.</FONT></P>
<P><FONT FACE="Courier, monospace">// A JDBC implementation that is
accessed via the DataSource API is not</FONT></P>
<P><FONT FACE="Courier, monospace">// automatically registered with
the DriverManager.</FONT></P>
<P><FONT FACE="Courier, monospace">// The DriverManager, Driver, and
DriverPropertyInfo interfaces</FONT></P>
<P><FONT FACE="Courier, monospace">// may be deprecated in the
future.</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">import
org.firebirdsql.jdbc.FBWrappingDataSource;</FONT></P>
<P><FONT FACE="Courier, monospace">import
org.firebirdsql.jca.FBConnectionRequestInfo;</FONT></P>
<P><FONT FACE="Courier, monospace">import org.firebirdsql.gds.GDS;</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">public final class
DataSourceExample</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">static public void main (String
args[]) throws Exception</FONT></P>
<P><FONT FACE="Courier, monospace">{</FONT></P>
<P><FONT FACE="Courier, monospace">// Create an Firebird data source
manually;</FONT></P>
<P><FONT FACE="Courier, monospace">FBWrappingDataSource dataSource =
new FBWrappingDataSource();</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Set the standard properties</FONT></P>
<P><FONT FACE="Courier, monospace">dataSource.setDatabaseName
(&quot;localhost/3050:c:/database/employee.gdb&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">dataSource.setDescription (&quot;An
example database of employees&quot;);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">/*</FONT></P>
<P><FONT FACE="Courier, monospace">* Following properties were not
deleted in order to show differences </FONT>
</P>
<P><FONT FACE="Courier, monospace">* between InterClient 2.01 data
source implementation and Firebird one.</FONT></P>
<P><FONT FACE="Courier, monospace">*/</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setDataSourceName
(&quot;Employee&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setPortNumber (3060);</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setNetworkProtocol
(&quot;jdbc:interbase:&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setRoleName (null);</FONT></P>
<P><FONT FACE="Courier, monospace">// Set the non-standard properties</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setCharSet
(interbase.interclient.CharacterEncodings.NONE);</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setSuggestedCachePages
(0);</FONT></P>
<P><FONT FACE="Courier, monospace">//dataSource.setSweepOnConnect
(false);</FONT></P>
<P><FONT FACE="Courier, monospace">/*</FONT></P>
<P><FONT FACE="Courier, monospace">* This is an example how to use
FBConnectionRequestInfo to specify</FONT></P>
<P><FONT FACE="Courier, monospace">* DPB that will be used for this
data source.</FONT></P>
<P><FONT FACE="Courier, monospace">*/</FONT></P>
<P><FONT FACE="Courier, monospace">FBConnectionRequestInfo cri =
dataSource.getConnectionRequestInfo();</FONT></P>
<P><FONT FACE="Courier, monospace">cri.setProperty(GDS.isc_dpb_lc_ctype,
&quot;NONE&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">cri.setProperty(GDS.isc_dpb_num_buffers,
1);</FONT></P>
<P><FONT FACE="Courier, monospace">cri.setProperty(GDS.isc_dpb_sql_dialect,
1);</FONT></P>
<P><FONT FACE="Courier, monospace">dataSource.setConnectionRequestInfo(cri);</FONT></P>
<P><BR><BR>
</P>
<P><FONT FACE="Courier, monospace">// Connect to the Firebird
DataSource</FONT></P>
<P><FONT FACE="Courier, monospace">try {</FONT></P>
<P><FONT FACE="Courier, monospace">dataSource.setLoginTimeout (10);</FONT></P>
<P><FONT FACE="Courier, monospace">java.sql.Connection c =
dataSource.getConnection (&quot;sysdba&quot;, &quot;masterkey&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">// At this point, there is no
implicit driver instance</FONT></P>
<P><FONT FACE="Courier, monospace">// registered with the driver
manager!</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;got
connection&quot;);</FONT></P>
<P><FONT FACE="Courier, monospace">c.close ();</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">catch (java.sql.SQLException e) {</FONT></P>
<P><FONT FACE="Courier, monospace">e.printStackTrace();</FONT></P>
<P><FONT FACE="Courier, monospace">System.out.println (&quot;sql
exception: &quot; + e.getMessage ());</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><FONT FACE="Courier, monospace">}</FONT></P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>20- Common Errors</FONT></P>
<P><FONT SIZE=4>1. Wrong URL</FONT></P>
<P>The most common error is having the wrong URL format for the
database. 
</P>
<P>The two formats accepted are:</P>
<P><BR><BR>
</P>
<P>Standard format= jdbc:firebirdsql:[//host[:port]/]&lt;database&gt;

</P>
<P>FB old format= jdbc:firebirdsql:[host[/port]:]&lt;database&gt;</P>
<P><BR><BR>
</P>
<P>Most Firebird/Interbase database file names end in &quot;.gdb&quot;.</P>
<P>People frequently forget to put that in the url.</P>
<P><BR><BR>
</P>
<P><FONT SIZE=4>2. Incorrect spelling in xml files.</FONT></P>
<P>When using JBoss or Tomcat or any environment that uses XML files
for 
</P>
<P>configuration, don't forget that case is important. Windows users 
</P>
<P>often make this mistake because Windows is insensitive to case.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>21. Compliance and Performance
Information</FONT></P>
<H2 STYLE="font-weight: medium"><FONT SIZE=4>Compliance Tests:</FONT></H2>
<P>The compliance was check with <A HREF="http://www.jDataMaster.com/">jDataMaster</A>,
which include more than 1000 tests, excluding:</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">CallableStatements 
	</P>
	<LI><P>Escape Syntax 
	</P>
</UL>
<P>FB type 4 driver pass all the tests excluding</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm">ResultSetMetaData.isReadOnly(i) 
	</P>
	<LI><P STYLE="margin-bottom: 0cm">ResultSetMetaData.isWritable(i) 
	</P>
	<LI><P>ResultSetMetaData.isDefinitivelyWritable(i) 
	</P>
</UL>
<P>The set/get tests don't include Blobs.</P>
<P>Firebird driver is the most JDBC compliant driver of those tested
with this tool, the next one fails on 90 tests, including all of the
most known RDBMS.</P>
<P><BR><BR>
</P>
<H2 STYLE="font-weight: medium"><FONT SIZE=4>Performance tests
compared with Interclient</FONT></H2>
<P>The results of the jDataMaster basic performance tests, are the
following</P>
<P>Local test</P>
<P>Duron 800MHz with 512MB and FB 1.0 without forced Writes</P>
<TABLE BORDER=1 CELLPADDING=2 CELLSPACING=5>
	<TR>
		<TD>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>Interclient</P>
		</TD>
		<TD>
			<P>Firebird Type 4</P>
		</TD>
		<TD>
			<P>FB as % of Interclient</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Insert 5000 records with autocommit</P>
		</TD>
		<TD>
			<P>8510 ms</P>
		</TD>
		<TD>
			<P>14307 ms</P>
		</TD>
		<TD>
			<P>168 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Read 5000 records with autocommit (x5)</P>
		</TD>
		<TD>
			<P>3052 ms</P>
		</TD>
		<TD>
			<P>3056 ms</P>
		</TD>
		<TD>
			<P>100 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Insert 5000 records with one transaction</P>
		</TD>
		<TD>
			<P>6650 ms</P>
		</TD>
		<TD>
			<P>5552 ms</P>
		</TD>
		<TD>
			<P>83 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Read 5000 records inside one transaction(x5)</P>
		</TD>
		<TD>
			<P>3990 ms</P>
		</TD>
		<TD>
			<P>3819 ms</P>
		</TD>
		<TD>
			<P>95 %</P>
		</TD>
	</TR>
</TABLE>
<P>Remote test</P>
<P>Client: Windows 2000 on Duron 800MHz with 512MB.<BR>Server: Suse
7.2 on AMD 500MHz with 256MB and FB 1.0.</P>
<TABLE BORDER=1 CELLPADDING=2 CELLSPACING=5>
	<TR>
		<TD>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P>Interclient</P>
		</TD>
		<TD>
			<P>Firebird Type 4</P>
		</TD>
		<TD>
			<P>FB as % of Interclient</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Insert 5000 records with autocommit</P>
		</TD>
		<TD>
			<P>16588 ms</P>
		</TD>
		<TD>
			<P>17525 ms</P>
		</TD>
		<TD>
			<P>106 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Read 5000x5 records with autocommit</P>
		</TD>
		<TD>
			<P>8082 ms</P>
		</TD>
		<TD>
			<P>6247 ms</P>
		</TD>
		<TD>
			<P>77 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Insert 5000 records with one transaction</P>
		</TD>
		<TD>
			<P>13009 ms</P>
		</TD>
		<TD>
			<P>6311 ms</P>
		</TD>
		<TD>
			<P>49 %</P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P>Read 5000x5 records inside one transaction</P>
		</TD>
		<TD>
			<P>11639 ms</P>
		</TD>
		<TD>
			<P>8670 ms</P>
		</TD>
		<TD>
			<P>75 %</P>
		</TD>
	</TR>
</TABLE>
<P>The time in each test is the average of 5 executions.</P>
<P><BR><BR>
</P>
<P>June-24-2002</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>22- History</FONT></P>
<P><BR><BR>
</P>
<P>The idea of writing a java translation of the C client library and
using it in an all-java driver originated in some discussions between
David Jencks and Jim Starkey. Alejandro Alberola provided the initial
translation of most of the client library functionality. I still
don't understand how he did it so quickly. David Jencks wrote the JCA
support and initial JDBC interfaces. Roman Rokytskyy wrote the
CallableStatement support, many of the trickier JDBC details, the
FBField implementation, and the character encoding support (among
many other things). Several others have contributed bug fixes.</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>23- Frequently Asked Questions</FONT></P>
<P><BR><BR>
</P>
<P>(Note: I'll be happy to start a FAQ and maintain it if someone can
tell me where the web site is for the driver and who to contact about
submitting the info. Rick)</P>
<P><BR><BR>
</P>
<P>A FAQ is located on the web site at: http:<A HREF="../../../../">//www</A>.???.com</P>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<P ALIGN=CENTER><FONT SIZE=5>24- To Do</FONT></P>
<P ALIGN=LEFT><BR><BR>
</P>
<P ALIGN=LEFT><FONT SIZE=3>This section lists tasks that need to be
done.</FONT></P>
<OL>
	<LI><P ALIGN=LEFT><FONT SIZE=3>Refactoring to support Weblogic. In
	progress.</FONT></P>
	<LI><P ALIGN=LEFT><FONT SIZE=3>Implement the unimplemented methods
	listed in section 2 above.</FONT></P>
	<LI><P ALIGN=LEFT><FONT SIZE=3>Implement the unimplemented optional
	features listed in section 2 above, where possible.</FONT></P>
</OL>
<P ALIGN=LEFT><BR><BR>
</P>
</BODY>
</HTML>
